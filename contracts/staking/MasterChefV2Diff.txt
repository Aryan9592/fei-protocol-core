3,4c3
< pragma solidity 0.6.12;
< pragma experimental ABIEncoderV2;
---
> pragma solidity ^0.8.0;
6,17c5,20
< import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
< import "@boringcrypto/boring-solidity/contracts/BoringBatchable.sol";
< import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
< import "./libraries/SignedSafeMath.sol";
< import "./interfaces/IRewarder.sol";
< import "./interfaces/IMasterChef.sol";
< 
< interface IMigratorChef {
<     // Take the current LP token address and return the new LP token address.
<     // Migrator should have full access to the caller's LP token.
<     function migrate(IERC20 token) external returns (IERC20);
< }
---
> import "./../refs/CoreRef.sol";
> import "./IRewardsDistributor.sol";
> import "./IRewarder.sol";
> import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
> import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
> 
> /// @notice migration functionality has been removed as this is only going to be used to distribute staking rewards
> 
> /// @notice The idea for this MasterChief V2 (MCV2) contract is therefore to be the owner of tribe token
> /// that is deposited into this contract.
> /// @notice This contract was forked from sushiswap and has been modified to distribute staking rewards in tribe.
> /// All legacy code that relied on MasterChef V1 has been removed so that this contract will pay out staking rewards in tribe.
> /// The assumption this code makes is that this MasterChief contract will be funded before going live and offering staking rewards.
> /// This contract will not have the ability to mint tribe.
> contract MasterChief is CoreRef, ReentrancyGuard {
>     using SafeERC20 for IERC20;
19,28c22,27
< /// @notice The (older) MasterChef contract gives out a constant number of SUSHI tokens per block.
< /// It is the only address with minting rights for SUSHI.
< /// The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token
< /// that is deposited into the MasterChef V1 (MCV1) contract.
< /// The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.
< contract MasterChefV2 is BoringOwnable, BoringBatchable {
<     using BoringMath for uint256;
<     using BoringMath128 for uint128;
<     using BoringERC20 for IERC20;
<     using SignedSafeMath for int256;
---
>     /// @notice Info of each users's reward debt and virtual amount
>     /// stored in a single pool
>     struct UserInfo {
>         int128 rewardDebt;
>         uint128 virtualAmount;
>     }
32,35c31,37
<     /// `rewardDebt` The amount of SUSHI entitled to the user.
<     struct UserInfo {
<         uint256 amount;
<         int256 rewardDebt;
---
>     /// `rewardDebt` The amount of Tribe entitled to the user.
>     /// assumption here is that we will never go over 2^128 -1
>     /// on any user deposits or reward debts
>     struct DepositInfo {
>         uint128 amount;
>         uint64 unlockBlock;
>         uint256 multiplier;
40c42
<     /// Also known as the amount of SUSHI to distribute per block.
---
>     /// Also known as the amount of Tribe to distribute per block.
42c44,45
<         uint128 accSushiPerShare;
---
>         uint128 accTribePerShare;
>         uint128 virtualTotalSupply;
44a48,58
>         bool unlocked; // this will allow an admin to unlock the pool if need be.
>         // Defaults to false so that users have to respect the lockup period
>     }
> 
>     /// @notice Info of each MCV2 pool rewards multipliers available.
>     /// map a pool id to a block lock time to a rewards multiplier
>     mapping (uint256 => mapping (uint64 => uint256)) public rewardMultipliers;
> 
>     struct RewardData {
>         uint64 lockLength;
>         uint256 rewardMultiplier;
47,54c61,62
<     /// @notice Address of MCV1 contract.
<     IMasterChef public immutable MASTER_CHEF;
<     /// @notice Address of SUSHI contract.
<     IERC20 public immutable SUSHI;
<     /// @notice The index of MCV2 master pool in MCV1.
<     uint256 public immutable MASTER_PID;
<     // @notice The migrator contract. It has a lot of power. Can only be set through governance (owner).
<     IMigratorChef public migrator;
---
>     /// @notice Address of Tribe contract.
>     IERC20 public immutable TRIBE;
62c70,71
< 
---
>     
>     mapping (uint256 => mapping(address => UserInfo)) public userInfo;
64c73
<     mapping (uint256 => mapping (address => UserInfo)) public userInfo;
---
>     mapping (uint256 => mapping (address => DepositInfo[])) public depositInfo;
66c75
<     uint256 public totalAllocPoint;
---
>     uint128 public totalAllocPoint;
68,69c77,80
<     uint256 private constant MASTERCHEF_SUSHI_PER_BLOCK = 1e20;
<     uint256 private constant ACC_SUSHI_PRECISION = 1e12;
---
>     uint256 private masterChefTribePerBlock = 1e20;
>     // variable has been made immutable to cut down on gas costs
>     uint256 private immutable ACC_TRIBE_PRECISION = 1e12;
>     uint256 public immutable SCALE_FACTOR = 1e18;
71c82
<     event Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);
---
>     event Deposit(address indexed user, uint256 indexed pid, uint256 amount, uint256 indexed depositID);
77,78c88,136
<     event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);
<     event LogInit();
---
>     event LogPoolMultiplier(uint256 indexed pid, uint64 indexed lockLength, uint256 indexed multiplier);
>     event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accTribePerShare);
>     /// @notice tribe withdraw event
>     event TribeWithdraw(uint256 amount);
> 
>     /// @param _core The Core contract address.
>     /// @param _tribe The TRIBE token contract address.
>     constructor(address _core, IERC20 _tribe) CoreRef(_core) {
>         TRIBE = _tribe;
>     }
> 
>     function updateBlockReward(uint256 newBlockReward) external onlyGovernor {
>         masterChefTribePerBlock = newBlockReward;
>     }
> 
>     /// @notice locks the pool so the users cannot withdraw until they have 
>     /// locked for the lockup period
>     /// @param _pid pool ID
>     function lockPool(uint256 _pid) external onlyGovernor {
>         PoolInfo storage pool = poolInfo[_pid];
>         pool.unlocked = false;
>     }
> 
>     /// @notice unlocks the pool so that users can withdraw before their tokens
>     /// have been locked for the entire lockup period
>     /// @param _pid pool ID
>     function unlockPool(uint256 _pid) external onlyGovernor {
>         PoolInfo storage pool = poolInfo[_pid];
>         pool.unlocked = true;
>     }
> 
>     /// @notice changes the pool multiplier
>     /// have been locked for the entire lockup period
>     /// @param _pid pool ID
>     /// @param lockLength lock length to change
>     /// @param newRewardsMultiplier updated rewards multiplier
>     function governorAddPoolMultiplier(
>         uint256 _pid,
>         uint64 lockLength, 
>         uint256 newRewardsMultiplier
>     ) external onlyGovernor {
>         PoolInfo storage pool = poolInfo[_pid];
>         uint256 currentMultiplier = rewardMultipliers[_pid][lockLength];
>         // if the new multplier is less than the current multiplier,
>         // then, you need to unlock the pool to allow users to withdraw
>         if (newRewardsMultiplier < currentMultiplier) {
>             pool.unlocked = true;
>         }
>         rewardMultipliers[_pid][lockLength] = newRewardsMultiplier;
80,99c138,145
<     /// @param _MASTER_CHEF The SushiSwap MCV1 contract address.
<     /// @param _sushi The SUSHI token contract address.
<     /// @param _MASTER_PID The pool ID of the dummy token on the base MCV1 contract.
<     constructor(IMasterChef _MASTER_CHEF, IERC20 _sushi, uint256 _MASTER_PID) public {
<         MASTER_CHEF = _MASTER_CHEF;
<         SUSHI = _sushi;
<         MASTER_PID = _MASTER_PID;
<     }
< 
<     /// @notice Deposits a dummy token to `MASTER_CHEF` MCV1. This is required because MCV1 holds the minting rights for SUSHI.
<     /// Any balance of transaction sender in `dummyToken` is transferred.
<     /// The allocation point for the pool on MCV1 is the total allocation point for all pools that receive double incentives.
<     /// @param dummyToken The address of the ERC-20 token to deposit into MCV1.
<     function init(IERC20 dummyToken) external {
<         uint256 balance = dummyToken.balanceOf(msg.sender);
<         require(balance != 0, "MasterChefV2: Balance must exceed 0");
<         dummyToken.safeTransferFrom(msg.sender, address(this), balance);
<         dummyToken.approve(address(MASTER_CHEF), balance);
<         MASTER_CHEF.deposit(MASTER_PID, balance);
<         emit LogInit();
---
>         emit LogPoolMultiplier(_pid, lockLength, newRewardsMultiplier);
>     }
> 
>     /// @notice sends tokens back to governance treasury. Only callable by governance
>     /// @param amount the amount of tokens to send back to treasury
>     function governorWithdrawTribe(uint256 amount) external onlyGovernor {
>         TRIBE.safeTransfer(address(core()), amount);
>         emit TribeWithdraw(amount);
106a153,207
>     /// @notice Returns the number of user deposits in a single pool.
>     function openUserDeposits(uint256 pid, address user) public view returns (uint256) {
>         return depositInfo[pid][user].length;
>     }
> 
>     /**
>      * @dev Returns the downcasted uint64 from uint256, reverting on
>      * overflow (when the input is greater than largest uint64).
>      *
>      * Counterpart to Solidity's `uint64` operator.
>      *
>      * Requirements:
>      *
>      * - input must fit into 64 bits
>      */
>     function toUint64(uint256 value) internal pure returns (uint64) {
>         require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
>         return uint64(value);
>     }
> 
>     /**
>      * @dev Returns the downcasted uint128 from uint256, reverting on
>      * overflow (when the input is greater than largest uint128).
>      *
>      * Counterpart to Solidity's `uint128` operator.
>      *
>      * Requirements:
>      *
>      * - input must fit into 128 bits
>      */
>     function toUint128(uint256 value) internal pure returns (uint128) {
>         require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
>         return uint128(value);
>     }
> 
>     /**
>      * @dev Returns the downcasted int128 from uint256, reverting on
>      * overflow (when the input is greater than largest int128).
>      *
>      * Counterpart to Solidity's `int128` operator.
>      *
>      * Requirements:
>      *
>      * - input must fit into 128 bits
>      */
>     function toSigned128(uint256 a) internal pure returns (int128) {
>         require(int256(a) <= type(int128).max, "SafeCast: value doesn't fit in 128 bits");
>         return int128(uint128(a));
>     }
> 
>     function signed128ToUint256(int128 a) internal pure returns (uint256 c) {
>         int256 b = int256(a);
>         c = uint256(b);
>     }
> 
112c213,219
<     function add(uint256 allocPoint, IERC20 _lpToken, IRewarder _rewarder) public onlyOwner {
---
>     /// @param rewardData Reward Multiplier data 
>     function add(
>         uint128 allocPoint,
>         IERC20 _lpToken,
>         IRewarder _rewarder,
>         RewardData[] calldata rewardData
>     ) external onlyGovernor {
114c221
<         totalAllocPoint = totalAllocPoint.add(allocPoint);
---
>         totalAllocPoint += allocPoint;
117a225,245
>         uint256 pid = poolInfo.length;
> 
>         require(rewardData.length != 0, "must specify rewards");
>         // loop over all of the arrays of lock data and add them to the rewardMultipliers mapping
>         for (uint256 i = 0; i < rewardData.length; i++) {
>             // if locklength is 0 and multiplier is not equal to scale factor, revert
>             if (rewardData[i].lockLength == 0) {
>                 require(rewardData[i].rewardMultiplier == SCALE_FACTOR, "invalid multiplier for 0 lock length");
>             } else {
>                 // else, assert that multplier is greater than or equal to scale factor
>                 require(rewardData[i].rewardMultiplier >= SCALE_FACTOR, "invalid multiplier, must be above scale factor");
>             }
> 
>             rewardMultipliers[pid][rewardData[i].lockLength] = rewardData[i].rewardMultiplier;
>             emit LogPoolMultiplier(
>                 pid,
>                 rewardData[i].lockLength,
>                 rewardData[i].rewardMultiplier
>             );
>         }
> 
119,121c247,251
<             allocPoint: allocPoint.to64(),
<             lastRewardBlock: lastRewardBlock.to64(),
<             accSushiPerShare: 0
---
>             allocPoint: toUint64(allocPoint),
>             virtualTotalSupply: 0, // virtual total supply starts at 0 as there is 0 initial supply
>             lastRewardBlock: toUint64(lastRewardBlock),
>             accTribePerShare: 0,
>             unlocked: false
123c253
<         emit LogPoolAddition(lpToken.length.sub(1), allocPoint, _lpToken, _rewarder);
---
>         emit LogPoolAddition(pid, allocPoint, _lpToken, _rewarder);
126c256
<     /// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.
---
>     /// @notice Update the given pool's TRIBE allocation point and `IRewarder` contract. Can only be called by the owner.
131,134c261,268
<     function set(uint256 _pid, uint256 _allocPoint, IRewarder _rewarder, bool overwrite) public onlyOwner {
<         totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);
<         poolInfo[_pid].allocPoint = _allocPoint.to64();
<         if (overwrite) { rewarder[_pid] = _rewarder; }
---
>     function set(uint256 _pid, uint128 _allocPoint, IRewarder _rewarder, bool overwrite) public onlyGovernor {
>         totalAllocPoint = (totalAllocPoint - poolInfo[_pid].allocPoint) + _allocPoint;
>         poolInfo[_pid].allocPoint = toUint64(_allocPoint);
> 
>         if (overwrite) {
>             rewarder[_pid] = _rewarder;
>         }
> 
138,142c272,274
<     /// @notice Set the `migrator` contract. Can only be called by the owner.
<     /// @param _migrator The contract address to set.
<     function setMigrator(IMigratorChef _migrator) public onlyOwner {
<         migrator = _migrator;
<     }
---
>     function _getPendingRewards(uint256 _pid, address _user) private view returns (uint256) {
>         PoolInfo memory pool = poolInfo[_pid];
>         UserInfo storage user = userInfo[_pid][_user];
144,153c276,287
<     /// @notice Migrate LP token to another LP contract through the `migrator` contract.
<     /// @param _pid The index of the pool. See `poolInfo`.
<     function migrate(uint256 _pid) public {
<         require(address(migrator) != address(0), "MasterChefV2: no migrator set");
<         IERC20 _lpToken = lpToken[_pid];
<         uint256 bal = _lpToken.balanceOf(address(this));
<         _lpToken.approve(address(migrator), bal);
<         IERC20 newLpToken = migrator.migrate(_lpToken);
<         require(bal == newLpToken.balanceOf(address(this)), "MasterChefV2: migrated balance must match");
<         lpToken[_pid] = newLpToken;
---
>         uint256 accTribePerShare = pool.accTribePerShare;
> 
>         if (block.number > pool.lastRewardBlock && pool.virtualTotalSupply != 0) {
>             uint256 blocks = block.number - pool.lastRewardBlock;
>             uint256 tribeReward = (blocks * tribePerBlock() * pool.allocPoint) / totalAllocPoint;
>             accTribePerShare = accTribePerShare + ((tribeReward * ACC_TRIBE_PRECISION) / pool.virtualTotalSupply);
>         }
> 
>         // use the virtual amount to calculate the users share of the pool and their pending rewards
>         return signed128ToUint256(
>             (toSigned128((user.virtualAmount) * accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION)) - int128(user.rewardDebt)
>         );
156c290
<     /// @notice View function to see pending SUSHI on frontend.
---
>     /// @notice View function to see all pending TRIBE on frontend.
159,170c293,295
<     /// @return pending SUSHI reward for a given user.
<     function pendingSushi(uint256 _pid, address _user) external view returns (uint256 pending) {
<         PoolInfo memory pool = poolInfo[_pid];
<         UserInfo storage user = userInfo[_pid][_user];
<         uint256 accSushiPerShare = pool.accSushiPerShare;
<         uint256 lpSupply = lpToken[_pid].balanceOf(address(this));
<         if (block.number > pool.lastRewardBlock && lpSupply != 0) {
<             uint256 blocks = block.number.sub(pool.lastRewardBlock);
<             uint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;
<             accSushiPerShare = accSushiPerShare.add(sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply);
<         }
<         pending = int256(user.amount.mul(accSushiPerShare) / ACC_SUSHI_PRECISION).sub(user.rewardDebt).toUInt256();
---
>     /// @return pending TRIBE reward for a given user.
>     function allPendingRewards(uint256 _pid, address _user) external view returns (uint256) {
>         return _getPendingRewards(_pid, _user);
182,185c307,309
<     /// @notice Calculates and returns the `amount` of SUSHI per block.
<     function sushiPerBlock() public view returns (uint256 amount) {
<         amount = uint256(MASTERCHEF_SUSHI_PER_BLOCK)
<             .mul(MASTER_CHEF.poolInfo(MASTER_PID).allocPoint) / MASTER_CHEF.totalAllocPoint();
---
>     /// @notice Calculates and returns the `amount` of TRIBE per block.
>     function tribePerBlock() public view returns (uint256) {
>         return masterChefTribePerBlock;
190,192c314,315
<     /// @return pool Returns the pool that was updated.
<     function updatePool(uint256 pid) public returns (PoolInfo memory pool) {
<         pool = poolInfo[pid];
---
>     function updatePool(uint256 pid) public {
>         PoolInfo storage pool = poolInfo[pid];
194,198c317,321
<             uint256 lpSupply = lpToken[pid].balanceOf(address(this));
<             if (lpSupply > 0) {
<                 uint256 blocks = block.number.sub(pool.lastRewardBlock);
<                 uint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;
<                 pool.accSushiPerShare = pool.accSushiPerShare.add((sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply).to128());
---
>             uint256 virtualSupply = pool.virtualTotalSupply;
>             if (virtualSupply > 0) {
>                 uint256 blocks = block.number - pool.lastRewardBlock;
>                 uint256 tribeReward = (blocks * tribePerBlock() * pool.allocPoint) / totalAllocPoint;
>                 pool.accTribePerShare = uint128(pool.accTribePerShare + ((tribeReward * ACC_TRIBE_PRECISION) / virtualSupply));
200,202c323,324
<             pool.lastRewardBlock = block.number.to64();
<             poolInfo[pid] = pool;
<             emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accSushiPerShare);
---
>             pool.lastRewardBlock = toUint64(block.number);
>             emit LogUpdatePool(pid, pool.lastRewardBlock, virtualSupply, pool.accTribePerShare);
206c328
<     /// @notice Deposit LP tokens to MCV2 for SUSHI allocation.
---
>     /// @notice Deposit LP tokens to MCV2 for TRIBE allocation.
209,212c331,342
<     /// @param to The receiver of `amount` deposit benefit.
<     function deposit(uint256 pid, uint256 amount, address to) public {
<         PoolInfo memory pool = updatePool(pid);
<         UserInfo storage user = userInfo[pid][to];
---
>     /// @param lockLength The length of time you would like to lock tokens
>     /// if locking is not enforced, this value can be 0. If locking is enforced,
>     /// a user must pass a valid lock length
>     /// @dev you can only deposit on a single deposit id once.
>     function deposit(uint256 pid, uint128 amount, uint64 lockLength) public {
>         updatePool(pid);
>         PoolInfo storage pool = poolInfo[pid];
>         UserInfo storage userPoolData = userInfo[pid][msg.sender];
>         DepositInfo memory user;
> 
>         uint256 multiplier = rewardMultipliers[pid][lockLength];
>         require(multiplier >= SCALE_FACTOR, "invalid multiplier");
215,216c345,362
<         user.amount = user.amount.add(amount);
<         user.rewardDebt = user.rewardDebt.add(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));
---
>         user.amount = amount;
>         user.unlockBlock = uint64(lockLength + block.number);
>         // set the multiplier here so that on withdraw we can easily reset the
>         // multiplier and remove the appropriate amount of virtual liquidity
>         user.multiplier = multiplier;
> 
>         // virtual amount is calculated by taking the users total deposited balance and multiplying
>         // it by the multiplier then adding it to the aggregated virtual amount
>         uint128 virtualAmountDelta = uint128((amount * multiplier) / SCALE_FACTOR);
>         userPoolData.virtualAmount += virtualAmountDelta;
>         // update reward debt after virtual amount is set by multiplying virtual amount delta by tribe per share
>         userPoolData.rewardDebt += int128(virtualAmountDelta * pool.accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION);
> 
>         // pool virtual total supply needs to increase here
>         pool.virtualTotalSupply += virtualAmountDelta;
> 
>         // add the new user struct into storage
>         depositInfo[pid][msg.sender].push(user);
221c367
<             _rewarder.onSushiReward(pid, to, to, 0, user.amount);
---
>             _rewarder.onSushiReward(pid, msg.sender, msg.sender, 0, userPoolData.virtualAmount);
226c372
<         emit Deposit(msg.sender, pid, amount, to);
---
>         emit Deposit(msg.sender, pid, amount, depositInfo[pid][msg.sender].length - 1);
231d376
<     /// @param amount LP token amount to withdraw.
233,234c378,380
<     function withdraw(uint256 pid, uint256 amount, address to) public {
<         PoolInfo memory pool = updatePool(pid);
---
>     function withdrawAllAndHarvest(uint256 pid, address to) external nonReentrant {
>         updatePool(pid);
>         PoolInfo storage pool = poolInfo[pid];
236a383,411
>         // gather and pay out users rewards
>         harvest(pid, msg.sender);
>         uint128 unlockedTotalAmount = 0;
>         uint128 virtualLiquidityDelta = 0;
> 
>         // iterate over all deposits this user has.
>         // aggregate the deltas
>         uint64 processedDeposits = 0;
>         for (uint256 i = 0; i < depositInfo[pid][msg.sender].length; i++) {
>             DepositInfo storage poolDeposit = depositInfo[pid][msg.sender][i];
>             // if the user has locked the tokens for at least the 
>             // lockup period or the pool has been unlocked, allow 
>             // user to withdraw their principle, otherwise skip this action
>             if (poolDeposit.unlockBlock > block.number && pool.unlocked == false) {
>                 continue;
>             }
>             // if we get past continue, it means that we are going to process this deposit
>             processedDeposits++;
> 
>             // gather the virtual and regular amount delta
>             unlockedTotalAmount += poolDeposit.amount;
>             virtualLiquidityDelta += uint128( (poolDeposit.amount * poolDeposit.multiplier) / SCALE_FACTOR );
> 
>             // zero out the user object as their amount will be withdrawn and all pending tribe will be paid out
>             poolDeposit.unlockBlock = 0;
>             poolDeposit.multiplier = 0;
>             poolDeposit.amount = 0;
>         }
> 
238,239c413,432
<         user.rewardDebt = user.rewardDebt.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));
<         user.amount = user.amount.sub(amount);
---
>         if (processedDeposits == depositInfo[pid][msg.sender].length) {
>             // remove the array of deposits and userInfo struct if we were able to withdraw from all deposits
>             // if we removed all liquidity, then we can just delete all the data we stored on this user
>             // in both depositinfo and userinfo, which means that their reward debt, and virtual liquidity
>             // are all zero'd.
>             delete depositInfo[pid][msg.sender];
>             delete userInfo[pid][msg.sender];
>         } else {
>             // if we didn't end up being able to withdraw all of the liquidity from all of our deposits
>             // then we will just update for the amounts that we did remove
>             // batched changes are done at the end of the function so that we don't
>             // write to these storage slots multiple times
>             user.virtualAmount -= virtualLiquidityDelta;
>             // set the reward debt to the new virtual amount
>             user.rewardDebt = int128(user.virtualAmount * pool.accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION);
>         }
> 
>         // regardless of whether or not we removed all of this users liquidity from the pool, we will need to
>         // subtract the virtual liquidity delta from the pool virtual total supply
>         pool.virtualTotalSupply -= virtualLiquidityDelta;
244c437
<             _rewarder.onSushiReward(pid, msg.sender, to, 0, user.amount);
---
>             _rewarder.onSushiReward(pid, msg.sender, to, 0, user.virtualAmount);
246,247d438
<         
<         lpToken[pid].safeTransfer(to, amount);
249c440,442
<         emit Withdraw(msg.sender, pid, amount, to);
---
>         lpToken[pid].safeTransfer(to, unlockedTotalAmount);
> 
>         emit Withdraw(msg.sender, pid, unlockedTotalAmount, to);
252c445
<     /// @notice Harvest proceeds for transaction sender to `to`.
---
>     /// @notice Withdraw LP tokens from MCV2.
254,256c447,458
<     /// @param to Receiver of SUSHI rewards.
<     function harvest(uint256 pid, address to) public {
<         PoolInfo memory pool = updatePool(pid);
---
>     /// @param amount LP token amount to withdraw.
>     /// @param to Receiver of the LP tokens.
>     function withdrawFromDeposit(
>         uint256 pid,
>         uint128 amount,
>         address to,
>         uint256 index
>     ) public {
>         require(depositInfo[pid][msg.sender].length > index, "invalid index");
>         updatePool(pid);
>         PoolInfo storage pool = poolInfo[pid];
>         DepositInfo storage poolDeposit = depositInfo[pid][msg.sender][index];
258,259c460,466
<         int256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);
<         uint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();
---
> 
>         // if the user has locked the tokens for at least the 
>         // lockup period or the pool has been unlocked by the governor,
>         // allow user to withdraw their principle
>         require(poolDeposit.unlockBlock <= block.number || pool.unlocked == true, "tokens locked");
> 
>         uint128 virtualAmountDelta = uint128( ( amount * poolDeposit.multiplier ) / SCALE_FACTOR );
262c469,472
<         user.rewardDebt = accumulatedSushi;
---
>         poolDeposit.amount -= amount;
>         user.rewardDebt = user.rewardDebt - toSigned128(user.virtualAmount * pool.accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION);
>         user.virtualAmount -= virtualAmountDelta;
>         pool.virtualTotalSupply -= virtualAmountDelta;
265,268d474
<         if (_pendingSushi != 0) {
<             SUSHI.safeTransfer(to, _pendingSushi);
<         }
<         
271c477
<             _rewarder.onSushiReward( pid, msg.sender, to, _pendingSushi, user.amount);
---
>             _rewarder.onSushiReward(pid, msg.sender, to, 0, user.virtualAmount);
274c480,482
<         emit Harvest(msg.sender, pid, _pendingSushi);
---
>         lpToken[pid].safeTransfer(to, amount);
> 
>         emit Withdraw(msg.sender, pid, amount, to);
276,277c484,485
<     
<     /// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.
---
> 
>     /// @notice Harvest proceeds for transaction sender to `to`.
279,282c487,490
<     /// @param amount LP token amount to withdraw.
<     /// @param to Receiver of the LP tokens and SUSHI rewards.
<     function withdrawAndHarvest(uint256 pid, uint256 amount, address to) public {
<         PoolInfo memory pool = updatePool(pid);
---
>     /// @param to Receiver of TRIBE rewards.
>     function harvest(uint256 pid, address to) public {
>         updatePool(pid);
>         PoolInfo storage pool = poolInfo[pid];
284,285c492,502
<         int256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);
<         uint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();
---
> 
>         // assumption here is that we will never go over 2^128 -1
>         int256 accumulatedTribe = int256( uint256(user.virtualAmount) * uint256(pool.accTribePerShare) ) / int256(ACC_TRIBE_PRECISION);
> 
>         // this should never happen
>         require(accumulatedTribe >= 0 || (accumulatedTribe - user.rewardDebt) < 0, "negative accumulated tribe");
> 
>         uint256 pendingTribe = uint256(accumulatedTribe - user.rewardDebt);
> 
>         // if pending tribe is ever negative, revert as this can cause an underflow as we turned this number to a uint
>         require(int256(pendingTribe) >= 0, "pendingTribe is less than 0");
288,290c505,506
<         user.rewardDebt = accumulatedSushi.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));
<         user.amount = user.amount.sub(amount);
<         
---
>         user.rewardDebt = int128(accumulatedTribe);
> 
292c508,510
<         SUSHI.safeTransfer(to, _pendingSushi);
---
>         if (pendingTribe != 0) {
>             TRIBE.safeTransfer(to, pendingTribe);
>         }
296c514
<             _rewarder.onSushiReward(pid, msg.sender, to, _pendingSushi, user.amount);
---
>             _rewarder.onSushiReward( pid, msg.sender, to, pendingTribe, user.virtualAmount);
299,302c517
<         lpToken[pid].safeTransfer(to, amount);
< 
<         emit Withdraw(msg.sender, pid, amount, to);
<         emit Harvest(msg.sender, pid, _pendingSushi);
---
>         emit Harvest(msg.sender, pid, pendingTribe);
305,308c520,522
<     /// @notice Harvests SUSHI from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.
<     function harvestFromMasterChef() public {
<         MASTER_CHEF.deposit(MASTER_PID, 0);
<     }
---
>     //////////////////////////////////////////////////////////////////////////////
>     // ----> if you call emergency withdraw, you are forfeiting your rewards <----
>     //////////////////////////////////////////////////////////////////////////////
314,317c528,553
<         UserInfo storage user = userInfo[pid][msg.sender];
<         uint256 amount = user.amount;
<         user.amount = 0;
<         user.rewardDebt = 0;
---
>         updatePool(pid);
>         PoolInfo storage pool = poolInfo[pid];
> 
>         uint128 totalUnlocked = 0;
>         uint128 virtualLiquidityDelta = 0;
>         for (uint256 i = 0; i < depositInfo[pid][msg.sender].length; i++) {
>             DepositInfo storage poolDeposit = depositInfo[pid][msg.sender][i];
> 
>             // if the user has locked the tokens for at least the 
>             // lockup period or the pool has been unlocked, allow 
>             // user to withdraw their principle
>             require(poolDeposit.unlockBlock <= block.number || pool.unlocked == true, "tokens locked");
> 
>             totalUnlocked += poolDeposit.amount;
> 
>             // update the aggregated deposit virtual amount
>             // update the virtualTotalSupply
>             virtualLiquidityDelta += uint128((poolDeposit.amount * poolDeposit.multiplier) / SCALE_FACTOR);
>         }
> 
>         // subtract virtualLiquidity Delta from the virtual total supply of this pool
>         pool.virtualTotalSupply -= virtualLiquidityDelta;
> 
>         // remove the array of deposits and userInfo struct
>         delete depositInfo[pid][msg.sender];
>         delete userInfo[pid][msg.sender];
325,326c561,562
<         lpToken[pid].safeTransfer(to, amount);
<         emit EmergencyWithdraw(msg.sender, pid, amount, to);
---
>         lpToken[pid].safeTransfer(to, totalUnlocked);
>         emit EmergencyWithdraw(msg.sender, pid, totalUnlocked, to);
