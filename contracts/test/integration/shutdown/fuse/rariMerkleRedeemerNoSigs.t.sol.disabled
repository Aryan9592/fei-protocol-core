// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {getCore, getAddresses, FeiTestAddresses} from "../../../utils/Fixtures.sol";
import {MockRariMerkleRedeemerNoSigs} from "../../../../mock/MockRariMerkleRedeemerNoSigs.sol";
import {RariMerkleRedeemer} from "../../../../shutdown/fuse/RariMerkleRedeemer.sol";
import {MainnetAddresses} from "../../fixtures/MainnetAddresses.sol";
import {Constants} from "../../../../Constants.sol";
import {Test} from "../../../libs/forge-standard/src/Test.sol";
import {console2} from "../../../libs/forge-standard/src/console2.sol";

/**
 * Library to assist with testing.
 */
library RariMerkleRedeemerTestingLib {
    /**
     * Returns the actual list of cTokens in address[] memory format
     */
    function getCTokens() public pure returns (address[] memory cTokens) {
        cTokens = new address[](20);

        cTokens(0) = address(0x001E407f497e024B9fb1CB93ef841F43D645CA4F);
        cTokens(1) = address(0x26267e41CeCa7C8E0f143554Af707336f27Fa051);
        cTokens(2) = address(0x3E5C122Ffa75A9Fe16ec0c69F7E9149203EA1A5d);
        cTokens(3) = address(0x647A36d421183a0a9Fa62717a64B664a24E469C7);
        cTokens(4) = address(0x6f95d4d251053483f41c8718C30F4F3C404A8cf2);
        cTokens(5) = address(0x7DBC3aF9251756561Ce755fcC11c754184Af71F7);
        cTokens(6) = address(0x7e9cE3CAa9910cc048590801e64174957Ed41d43);
        cTokens(7) = address(0x88d3557eB6280CC084cA36e425d6BC52d0A04429);
        cTokens(8) = address(0x8922C1147E141C055fdDfc0ED5a119f3378c8ef8);
        cTokens(9) = address(0x8E4E0257A4759559B4B1AC087fe8d80c63f20D19);
        cTokens(10) = address(0x9de558FCE4F289b305E38ABe2169b75C626c114e);
        cTokens(11) = address(0xA54c548d11792b3d26aD74F5f899e12CDfD64Fd6);
        cTokens(12) = address(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47);
        cTokens(13) = address(0xF148cDEc066b94410d403aC5fe1bb17EC75c5851);
        cTokens(14) = address(0xFA1057d02A0C1a4885851e3F4fD496Ee7D38F56e);
        cTokens(15) = address(0xbB025D470162CC5eA24daF7d4566064EE7f5F111);
        cTokens(16) = address(0xd8553552f8868C1Ef160eEdf031cF0BCf9686945);
        cTokens(17) = address(0xda396c927e3e6BEf77A98f372CE431b49EdEc43D);
        cTokens(18) = address(0xe097783483D1b7527152eF8B150B99B9B2700c8d);
        cTokens(19) = address(0xe92a3db67e4b6AC86114149F522644b34264f858);

        return cTokens;
    }
}

contract RariMerkleRedeemerIntegrationTest is Test {
    // redeemerNoSigs is a simple subclass of redeemer that doesn't actually verify signatures
    // we use this to test against the real sample data
    MockRariMerkleRedeemerNoSigs public redeemerNoSigs;

    // redeemer is the actual full redeemer contract
    // we generated fake data from accounts we know the privkeys to so that we can fully test
    // the sign-claim-redeem path, with real signatures (but with fake/sample data)
    RariMerkleRedeemer public redeemer;

    // test addresses & privkeys
    address[] internal addresses;
    uint256[] internal keys;

    address private constant realUser0 = 0xb2d5CB72A621493fe83C6885E4A776279be595bC;
    address private constant realUser1 = 0x37349d9cc523D28e6aBFC03fc5F44879bC8BfFD9;

    function setUp() public {
        (addresses, keys) = getTestAccounts();

        redeemerNoSigs = new MockRariMerkleRedeemerNoSigs(
            MainnetAddresses.FEI,
            RariMerkleRedeemerTestingLib.getCTokens(),
            RariMerkleRedeemerTestingLib.getExampleRates(),
            RariMerkleRedeemerTestingLib.getExampleRoots()
        );

        redeemer = new RariMerkleRedeemer(
            MainnetAddresses.FEI,
            RariMerkleRedeemerTestingLib.getCTokens(),
            RariMerkleRedeemerTestingLib.getExampleRates(),
            RariMerkleRedeemerTestingLib.getExampleRootsWithGeneratedAccounts()
        );

        // give the redeemer contracts a bunch of fei
        deal(MainnetAddresses.FEI, address(redeemerNoSigs), 100_000_000_000e18);
        deal(MainnetAddresses.FEI, address(redeemer), 100_000_000_000e18);

        // give users one and two (from the real sample data) and the first generated address ctokens
        deal(cToken0, realUser0, 100_000_000e18);
        deal(cToken0, realUser1, 100_000_000e18);

        // label some stuff to make testing more understandable
        vm.label(realUser0, "User0");
        vm.label(realUser1, "User1");
        vm.label(addresses[0], "GeneratedAddress0");
        vm.label(addresses[1], "GeneratedAddress1");
    }

    /**
     * Helper function to get 100 test user accounts
     * Can use the privkeys with vm.sign and can impersonate with pranks
     */
    function getTestAccounts() internal returns (address[] memory _addresses, uint256[] memory _keys) {
        _addresses = new address[](100);
        _keys = new uint256[](100);

        for (uint256 i = 0; i < 100; i++) {
            (_addresses[i], _keys[i]) = makeAddrAndKey(vm.toString(i));
        }
    }

    /**
     * Test the main sign-claim-redeem flow with the sample data; uses the subclassed redeemer
     * contract which does not actually check signatures (since we dont have their private keys)
     */
    function testHappyPathNoSigChecks() public {
        RariMerkleRedeemerTestingLib.UserData[] memory users = RariMerkleRedeemerTestingLib.getUsers();

        address[] memory cTokensToTransfer = new address[](1);
        cTokensToTransfer[0] = cToken0;

        uint256[] memory amounts0 = new uint256[](1);
        amounts0[0] = users[0].balance;

        uint256[] memory amounts1 = new uint256[](1);
        amounts1[0] = users[1].balance;

        bytes32[][] memory proofs = RariMerkleRedeemerTestingLib.getExampleProofs();

        // when calling signAndClaimAndRedeem we take in an array of ctokens, amounts and proofs
        // thus we need to encapsulate everything into an array

        bytes32[][] memory proofZero = new bytes32[][](1);
        bytes32[][] memory proofOne = new bytes32[][](1);

        proofZero[0] = proofs[0];
        proofOne[0] = proofs[1];

        {
            vm.startPrank(users[0].user);
            IERC20(cTokensToTransfer[0]).approve(address(redeemerNoSigs), 100_000_000e18);
            uint256 user0PreBal = IERC20(cTokensToTransfer[0]).balanceOf(users[0].user);
            uint256 baseTokenStartBalance0 = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[0].user);
            redeemerNoSigs.signAndClaimAndRedeem("0xFFFF", cTokensToTransfer, amounts0, amounts0, proofZero);
            uint256 baseTokenEndBalance0 = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[0].user);
            assertEq(
                baseTokenEndBalance0 - baseTokenStartBalance0,
                amounts0[0] * 1,
                "User 0 base token balance not correct"
            );
            uint256 user0PostBal = IERC20(cTokensToTransfer[0]).balanceOf(users[0].user);
            assertEq(user0PreBal - user0PostBal, amounts0[0], "User 0 ctoken balance not correct");
        }

        {
            changePrank(users[1].user);
            IERC20(cTokensToTransfer[0]).approve(address(redeemerNoSigs), 100_000_000e18);
            uint256 user1PreBal = IERC20(cTokensToTransfer[0]).balanceOf(users[1].user);
            uint256 baseTokenStartBalance1 = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[1].user);
            redeemerNoSigs.signAndClaimAndRedeem("0xFFFF", cTokensToTransfer, amounts1, amounts1, proofOne);
            uint256 baseTokenEndBalance1 = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[1].user);
            assertEq(
                baseTokenEndBalance1 - baseTokenStartBalance1,
                amounts1[0] * 1,
                "User 1 base token balance not correct"
            );
            uint256 user1PostBal = IERC20(cTokensToTransfer[0]).balanceOf(users[1].user);
            assertEq(user1PreBal - user1PostBal, amounts1[0], "User 1 ctoken balance not correct");
            vm.stopPrank();
        }
    }

    /**
     * Test the main sign-claim-redeem flow with the sample data; uses the subclassed redeemer
     * contract which does not actually check signatures (since we dont have their private keys)
     * This second test provides separate values for amountsToClaim and amountsToRedeem
     */
    function testHappyPathNoSigChecksSeparateAmounts() public {
        RariMerkleRedeemerTestingLib.UserData[] memory users = RariMerkleRedeemerTestingLib.getUsers();

        address[] memory cTokensToTransfer = new address[](1);
        cTokensToTransfer[0] = cToken0;

        uint256[] memory amountsToClaim1 = new uint256[](1);
        amountsToClaim1[0] = users[1].balance;

        uint256[] memory amountsToRedeem1 = new uint256[](1);
        amountsToRedeem1[0] = users[1].balance - 1;

        bytes32[][] memory proofs = RariMerkleRedeemerTestingLib.getExampleProofs();

        // when calling signAndClaimAndRedeem we take in an array of ctokens, amounts and proofs
        // thus we need to encapsulate everything into an array

        bytes32[][] memory proofOne = new bytes32[][](1);

        proofOne[0] = proofs[1];

        changePrank(users[1].user);
        IERC20(cTokensToTransfer[0]).approve(address(redeemerNoSigs), 100_000_000e18);
        uint256 cTokenStartBalance = IERC20(cTokensToTransfer[0]).balanceOf(users[1].user);
        uint256 baseTokenStartBalance = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[1].user);
        redeemerNoSigs.signAndClaimAndRedeem("0xFFFF", cTokensToTransfer, amountsToClaim1, amountsToRedeem1, proofOne);
        uint256 basetTokenEndBalance = IERC20(redeemerNoSigs.baseToken()).balanceOf(users[1].user);
        assertEq(basetTokenEndBalance - baseTokenStartBalance, amountsToRedeem1[0] * 1);
        uint256 cTokenEndBalance = IERC20(cTokensToTransfer[0]).balanceOf(users[1].user);
        assertEq(cTokenStartBalance - cTokenEndBalance, amountsToRedeem1[0]);
        vm.stopPrank();
    }

    /**
     * Test the main sign-claim-redeem flow with fake/generated data; uses the real redeemer
     * contract (but with the fake merkle data) since we *do* have their private keys
     */
    function testWithGeneratedAccounts() public {
        address[] memory cTokensToTransfer = new address[](1);
        cTokensToTransfer[0] = cToken0;

        uint256[] memory amounts0 = new uint256[](1);
        amounts0[0] = 1;

        bytes32[][] memory proofs = RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts();
        bytes32[][] memory proofZero = new bytes32[][](1);

        proofZero[0] = proofs[0];

        vm.startPrank(addresses[0]);

        IERC20(cTokensToTransfer[0]).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        uint256 cTokenStartBalance = IERC20(cTokensToTransfer[0]).balanceOf(addresses[0]);
        uint256 baseTokenStartBalance = IERC20(redeemerNoSigs.baseToken()).balanceOf(addresses[0]);
        redeemer.signAndClaimAndRedeem(signature0, cTokensToTransfer, amounts0, amounts0, proofZero);
        uint256 cTokenEndBalance = IERC20(cTokensToTransfer[0]).balanceOf(addresses[0]);
        uint256 baseTokenEndBalance = IERC20(redeemerNoSigs.baseToken()).balanceOf(addresses[0]);
        assertEq(cTokenStartBalance - cTokenEndBalance, amounts0[0] * 1);
        assertEq(baseTokenEndBalance - baseTokenStartBalance, amounts0[0] * 1);
        vm.stopPrank();
    }

    function testNonAtomicRedemption() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature0);
        redeemer.claim(cToken0, 1, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[0]);
        uint256 baseBalPre = IERC20(redeemerNoSigs.baseToken()).balanceOf(addresses[0]);
        uint256 cTokenBalPre = IERC20(cToken0).balanceOf(addresses[0]);
        redeemer.redeem(cToken0, 1);
        uint256 baseBalPost = IERC20(redeemerNoSigs.baseToken()).balanceOf(addresses[0]);
        uint256 cTokenBalPost = IERC20(cToken0).balanceOf(addresses[0]);
        assertEq(cTokenBalPre - cTokenBalPost, 1);
        assertEq(baseBalPost - baseBalPre, 1);

        vm.stopPrank();
    }

    function testCannotSignTwice() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature0);

        vm.expectRevert("User has already signed");
        redeemer.sign(signature0);

        vm.stopPrank();
    }

    function testCannotClaimTwice() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature0);
        redeemer.claim(cToken0, 1, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[0]);

        bytes32[] memory proof = RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[0];
        vm.expectRevert("User has already claimed for this cToken.");
        redeemer.claim(cToken0, 1, proof);

        vm.stopPrank();
    }

    function testCannotClaimEmptyProof() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature0);
        vm.expectRevert("Merkle proof not valid.");
        redeemer.claim(cToken0, 1, new bytes32[](0));

        vm.stopPrank();
    }

    function testCannotClaimInvalidAmount() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());

        bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature0);
        vm.expectRevert("Merkle proof not valid.");
        redeemer.claim(cToken0, 2, new bytes32[](0));

        vm.stopPrank();
    }

    function testCannotClaimNonExistentUser() public {
        vm.startPrank(addresses[99]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[99], redeemer.MESSAGE_HASH());

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        redeemer.sign(signature);
        vm.expectRevert("Merkle proof not valid.");
        redeemer.claim(cToken0, 2, new bytes32[](0));

        vm.stopPrank();
    }

    function testCannotClaimWithoutSigning() public {
        vm.startPrank(addresses[0]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);

        bytes32[] memory proof = RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[0];

        vm.expectRevert("User has not signed.");
        redeemer.claim(cToken0, 1, proof);

        vm.stopPrank();
    }

    function testCannotRedeemWithoutApproval() public {
        vm.startPrank(addresses[1]);

        //IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        uint256 amount = 11152021915736699992171534;

        deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.sign(signature);
        redeemer.claim(cToken0, amount, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[1]);

        vm.expectRevert("SafeERC20: ERC20 operation did not succeed");
        redeemer.redeem(cToken0, amount);

        vm.stopPrank();
    }

    function testCannotRedeemWithoutcTokens() public {
        vm.startPrank(addresses[1]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        uint256 amount = 11152021915736699992171534;

        //deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.sign(signature);
        redeemer.claim(cToken0, amount, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[1]);

        vm.expectRevert("SafeERC20: ERC20 operation did not succeed");
        redeemer.redeem(cToken0, amount);

        vm.stopPrank();
    }

    function testCannotRedeemTooMuch() public {
        vm.startPrank(addresses[1]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        uint256 amount = 11152021915736699992171534;

        deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.sign(signature);
        redeemer.claim(cToken0, amount, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[1]);
        redeemer.redeem(cToken0, amount - 1);
        redeemer.redeem(cToken0, 1);

        vm.expectRevert("Amount exceeds available remaining claim.");
        redeemer.redeem(cToken0, 1);

        vm.stopPrank();
    }

    function testRedeemInParts() public {
        vm.startPrank(addresses[1]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        uint256 amount = 11152021915736699992171534;

        deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.sign(signature);
        redeemer.claim(cToken0, amount, RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts()[1]);
        redeemer.redeem(cToken0, amount - 1);
        redeemer.redeem(cToken0, 1);

        vm.stopPrank();
    }

    function testRedeemInPartsSeparateAmounts() public {
        vm.startPrank(addresses[1]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        address[] memory cTokensToTransfer = new address[](1);
        cTokensToTransfer[0] = cToken0;

        uint256 amount = 11152021915736699992171534;

        uint256[] memory amountsToClaim = new uint256[](1);
        amountsToClaim[0] = amount;

        uint256[] memory amountsToRedeem = new uint256[](1);
        amountsToRedeem[0] = amount - 1;

        bytes32[][] memory proofs = RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts();
        bytes32[][] memory proofZero = new bytes32[][](1);
        proofZero[0] = proofs[1];

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.signAndClaimAndRedeem(signature, cTokensToTransfer, amountsToClaim, amountsToRedeem, proofZero);
        redeemer.redeem(cToken0, 1);

        vm.stopPrank();
    }

    function testRedeemInPartsSeparateAmountsSecondAmountTooMuch() public {
        vm.startPrank(addresses[1]);

        IERC20(cToken0).approve(address(redeemer), 100_000_000e18);
        (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[1], redeemer.MESSAGE_HASH());

        address[] memory cTokensToTransfer = new address[](1);
        cTokensToTransfer[0] = cToken0;

        uint256 amount = 11152021915736699992171534;

        uint256[] memory amountsToClaim = new uint256[](1);
        amountsToClaim[0] = amount;

        uint256[] memory amountsToRedeem = new uint256[](1);
        amountsToRedeem[0] = amount - 1;

        bytes32[][] memory proofs = RariMerkleRedeemerTestingLib.getExampleProofsWithGeneratedAccounts();
        bytes32[][] memory proofZero = new bytes32[][](1);
        proofZero[0] = proofs[1];

        bytes memory signature = bytes.concat(r0, s0, bytes1(v0));

        deal(cToken0, addresses[1], 100_000_000e18);

        redeemer.signAndClaimAndRedeem(signature, cTokensToTransfer, amountsToClaim, amountsToRedeem, proofZero);

        vm.expectRevert("Amount exceeds available remaining claim.");
        redeemer.redeem(cToken0, 2);

        vm.stopPrank();
    }

    function testMultipleProofs() public {
        // user 0x3ee505ba316879d246a8fd2b3d7ee63b51b44fab has 2 cTokens that he can claim in the real sample dataset:
        // ctoken 0xd8553552f8868c1ef160eedf031cf0bcf9686945, balance 993589106605953983
        // ctoken 0xbb025d470162cc5ea24daf7d4566064ee7f5f111, balance 690998780903

        bytes32[][] memory proofs = new bytes32[][](2);

        /* proof of 0xd855... ctoken:
            [
                "0x62dca27c719923b0b4153289b81c241bc8ef47f5cad5ec58ade92445aeb39425",
                "0x71cccc05bcc088efcb703861a77652785d97b902f142e54a88aa086e1a0b4b9d",
                "0x7ea144047c7d80af5adede075b1413985ae8c6414b3852bbf1eed5306cfe64da",
                "0x7f2f9d975d83fff6601d9a42c2d455427fc1905d1852e4f140b34ce94829ff6e",
                "0x9593e7925a7f31febb5129f974e732afcfdec22b7eb3c9c89d4e06d830d5cabd",
                "0x8f6e1401206c2969f4a2c923485ed4830a6c3081c51c899d7ec92c37ecbc76b9",
                "0x4e040b0a8945a716cefd1b511d9a02fa100ae18e738f40626e2afd4a112d0f82"
            ]
        */

        bytes32[] memory proofZero = new bytes32[](7);

        proofZero[0] = bytes32(0x62dca27c719923b0b4153289b81c241bc8ef47f5cad5ec58ade92445aeb39425);
        proofZero[1] = bytes32(0x71cccc05bcc088efcb703861a77652785d97b902f142e54a88aa086e1a0b4b9d);
        proofZero[2] = bytes32(0x7ea144047c7d80af5adede075b1413985ae8c6414b3852bbf1eed5306cfe64da);
        proofZero[3] = bytes32(0x7f2f9d975d83fff6601d9a42c2d455427fc1905d1852e4f140b34ce94829ff6e);
        proofZero[4] = bytes32(0x9593e7925a7f31febb5129f974e732afcfdec22b7eb3c9c89d4e06d830d5cabd);
        proofZero[5] = bytes32(0x8f6e1401206c2969f4a2c923485ed4830a6c3081c51c899d7ec92c37ecbc76b9);
        proofZero[6] = bytes32(0x4e040b0a8945a716cefd1b511d9a02fa100ae18e738f40626e2afd4a112d0f82);

        /* proof of 0xbb02... ctoken:
            [
                "0x559b86b696ea2560904747957cb4b6c622938a2253a7c564224010453dec5910",
                "0x00df7f59ac7c7df48999c1e7879a35d4b05650a4c1407f65a150fc362f78746d",
                "0xa5a7e6945e1ceba6d94998701ae8afd0ab99d85d9203f44b360d5b011b41af4e",
                "0x34af766f69be5f7fb507f8e41b8cb6d1d1fa40d90814072945d764536d46b59b",
                "0x4437c9684809f08315750d4062f27c2fb831a6d921bd36d1775770d36a7b9008",
                "0x327803747b0f1dd3d0103cc4ef0aba2b1155f78532eb926691a170428e2e2932",
                "0x227e55550409b39e95170a8f5ddb3fc56e5fad27cfdd658a8e587ea344ba674e"
            ]
        */

        bytes32[] memory proofOne = new bytes32[](7);

        proofOne[0] = bytes32(0x559b86b696ea2560904747957cb4b6c622938a2253a7c564224010453dec5910);
        proofOne[1] = bytes32(0x00df7f59ac7c7df48999c1e7879a35d4b05650a4c1407f65a150fc362f78746d);
        proofOne[2] = bytes32(0xa5a7e6945e1ceba6d94998701ae8afd0ab99d85d9203f44b360d5b011b41af4e);
        proofOne[3] = bytes32(0x34af766f69be5f7fb507f8e41b8cb6d1d1fa40d90814072945d764536d46b59b);
        proofOne[4] = bytes32(0x4437c9684809f08315750d4062f27c2fb831a6d921bd36d1775770d36a7b9008);
        proofOne[5] = bytes32(0x327803747b0f1dd3d0103cc4ef0aba2b1155f78532eb926691a170428e2e2932);
        proofOne[6] = bytes32(0x227e55550409b39e95170a8f5ddb3fc56e5fad27cfdd658a8e587ea344ba674e);

        proofs[0] = proofZero;
        proofs[1] = proofOne;

        address user = 0x3Ee505bA316879d246a8fD2b3d7eE63b51B44FAB;
        vm.startPrank(user);

        IERC20(cToken0).approve(address(redeemerNoSigs), 100_000_000e18);

        uint256 amount0 = 993589106605953983;
        uint256 amount1 = 690998780903;

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = amount0;
        amounts[1] = amount1;

        address _cToken0 = 0xd8553552f8868C1Ef160eEdf031cF0BCf9686945;
        address _cToken1 = 0xbB025D470162CC5eA24daF7d4566064EE7f5F111;

        address[] memory cTokens = new address[](2);
        cTokens[0] = _cToken0;
        cTokens[1] = _cToken1;

        deal(_cToken0, user, 100_000_000e18);
        deal(_cToken1, user, 100_000_000e18);

        redeemerNoSigs.sign("0xFFFF");
        redeemerNoSigs.multiClaim(cTokens, amounts, proofs);

        uint256 baseTokenBalPre = IERC20(redeemerNoSigs.baseToken()).balanceOf(user);
        uint256 cToken0BalPre = IERC20(_cToken0).balanceOf(user);
        uint256 cToken1BalPre = IERC20(_cToken1).balanceOf(user);

        IERC20(_cToken0).approve(address(redeemerNoSigs), type(uint256).max);
        IERC20(_cToken1).approve(address(redeemerNoSigs), type(uint256).max);

        redeemerNoSigs.multiRedeem(cTokens, amounts);

        uint256 cToken0BalPost = IERC20(_cToken0).balanceOf(user);
        uint256 cToken1BalPost = IERC20(_cToken1).balanceOf(user);
        uint256 baseTokenBalPost = IERC20(redeemerNoSigs.baseToken()).balanceOf(user);

        assertEq(cToken0BalPre - cToken0BalPost, amount0, "ctoken 0 amount incorrect");
        assertEq(cToken1BalPre - cToken1BalPost, amount1, "ctoken 1 amount incorrect");
        assertEq(baseTokenBalPost - baseTokenBalPre, (1 * amount0) + (2 * amount1), "base token amount incorrect");

        vm.stopPrank();
    }
}
